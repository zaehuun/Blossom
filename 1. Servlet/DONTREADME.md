**서블릿**이란...  

 흠 아무래도 예전엔 클라이언트가 서버에게 페이지를 요청하면 서버는 정적인 페이지만 넘겨줬었음.  
근데 정적인 페이지니까 미리 만들어 놓은 페이지를 클라이언트에게 넘겨주니 되게 딱딱하고 실시간성도 보장이 안 됐음. 특히 주가를 나타낼 때..  
이걸 서버 쪽에서 주가가 업데이트 될 때마다 5분 주기로 하나 하나 다 고치는 것도 상당히 귀찮은 문제임.  
그래서 서버는 WAS(웹 어플리케이션 서버)를 하나 두고 요청이 들어오면 WAS에게 무책임하게 넘김.  
그럼 WAS는 어쩔 수 없이 요청에 맞는 기능을 수행하기 위해 서블릿을 실행하여 요청에 맞는 페이지 결과를 만들어서 서버에게 보내고 서버는 그 페이지를 클라이언트에게 보냄  
동적인 페이지가 이런 느낌임. 방금 말한 것처럼 요청 들어오면 미리 만들어 놓은 페이지를 보내는 것이 아니라 요청에 맞는 페이지를 만들어서 보내줌.  
//물론 정적 페이지를 보내줄 때도 있는데 이런 경우는 WAS에게 넘기지 않고 서버에서 해결 함.  
  
이런 기능을 하는 것이 서블릿이고 서블릿은 자바로 만들어진 CGI 프로그램임  
※CGI -  서버 프로그램에서 다른 프로그램을 불러내고, 그 처리 결과를 클라이언트에 송신하는 방법이 고안되었다. 이를 실현하기 위한 서버 프로그램과 외부 프로그램과의 연계법을 정한 것  

자바로 작성된 거라 자바의 일반적인 특징을 모두 가지긴 함. 근데 일반 자바 프로그램이랑은 다르게 독자적으로 실행은 안 되고 컨테이너에서만 실행 됨.  
자바의 쓰레드 기능을 아주 잘 활용함. 즉, 여러 클라이언트한테서 같은 동적 페이지 요청이 여러 개가 들어오면 (여기부터는 약간 뇌피셜) 서버는 또 무책임하게 WAS에게 다 넘기고 WAS는 또 어쩔 수 없이 작업을 하게 되는데 서블릿을 요청의 개수만큼 생성해서 돌리는 것이 아니라 하나만 만들어 놓고 그 서블릿 하나로 다 처리를 함. 12첩반상을 먹으면 젓가락 12개 놓고 먹는 게 아니라 하나로만 먹는 느낌이다.
  
그니까 아마 서블릿의 동작 과정이  
1. WAS가 요청을 수행하려 하면 해당 요청을 수행하는 서블릿이 이미 메모리에 있는 지 확인.  
2. 없다면 생성해서 해당 요청을 수행하고, 있다면 그 서블릿으로 요청 수행.  
3. 서블릿이 언제 삭제가 되는 지는 아직 모르겠으나 눈치껏 자길 찾는 사람이 없다면 조용히 혼자 사라졌으면 좋겠음. 이건 나중에 찾아봐야지  
--------------------------------------------------------------------------  
**서블릿 생명주기** 메서드 기능  
-초기화 단계 : init() 호출 -> 서블릿 요청 시 맨 처음 한 번만 호출, 서블릿 생성 시 초기화 작업을 주로 수행  
-작업 수행 단계 : doget() or dopost() 호출 -> 서블릿 요청 시 매번 호출, 실제로 클라이언트가 요청하는 작업 수행  
-종료 단계 : destroy() 호출 -> 서블릿이 기능을 수행하고 메모리에서 소멸될 때 호출, 서블릿의 마무리 작업을 주로 수행   

※초기 설정과 종료 작업이 필요 없다면 init() destroy() 생략 가능  
---------------------------------------------------------------------
서블릿을 맵핑할 때 해당 프로젝트의 web.xml 파일에  
  <servlet> <!-- 브라우저에서 요청하는 매핑 이름에 대해 실제로 실행하는 서블릿 클래스를 설정하는 태그 -->  
  	<servlet-name>aaa</servlet-name> <!-- 아래 servlet-mapping 태그의 servlet-name 태그와 값이 동일 -->   
  	<servlet-class>servlet2.ex.FirstServlet</servlet-class> <!--  브라우저에서 요청하는 매핑 이름에 대해 실제로 기능을 수행하는 서블릿 클래스 설정 -->  
  </servlet>  
  <servlet-mapping>  
  	<servlet-name>aaa</servlet-name> <!-- 매핑 이름으로 요청 시 값이 같은 servlet 태그 안의 servlet-name 태그와 연결 -->  
  	<url-pattern>/first</url-pattern> <!-- 브라우저에서 servlet2.ex.FirstServlet을 요청하는 논리적인 서블릿 이름 -->  
  </servlet-mapping>  
해당 코드를 추가해서 서블릿을 맵핑시킬 수 있음  
이렇게 하면 http://localhost:8080/servlet2/servlet2.ex.FirstServlet을  http://localhost:8080/servlet2/first로 호출할 수 있음  
**사용이유?**  
아무래도 맵핑 전 상태처럼 클래스 이름이 다 노출된다면 이름만 보고 해당 클래스의 역할이 뭔 지를 유추해서 악용될 위험이 있으니 맵핑을 이용하여 숨김  

근데 클래스마다 web.xml에 저렇게 코드로 맵핑하는 건 너무 귀찮음  
@WebServlet("/third")  
public class ThirdServlet extends HttpServlet { ~~ }  
  
web.xml에 맵핑하지 않고 해당 클래스 머리 위에 저렇게 직접 맵핑을 시킬 수 있음. **어노테이션**이라고도 부르고 **애너테이션**이라고도 부름.  
나는 어노테이션이 편하다.  
아무 클래서 머리 위에 저렇게 쓴다고 해서 맵핑이 되는 게 아니라 HttpServlet을 상속 받아야 맵핑이 된다!..  

  
