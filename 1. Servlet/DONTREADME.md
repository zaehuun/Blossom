**서블릿**이란  
---------------------------------------------------------------------
1. 과거엔 클라이언트가 서버에 페이지를 요청하면 ***정적인 페이지***만 넘겨줬었다.  
2. 미리 만들어 놓은 페이지만을 넘겨주니 페이지가 딱딱하고 실시간성도 보장이 되지 않았다.  
3. 실시간으로 정보를 업데이트를 해야 하는 주가를 위해 프로그래머가 5분 주기로 계속 업데이트 하는 것은 너무 무리..!  
4. 이를 위해 서버는 ***동적인 페이지***를 만들어낼 수 있는 ***WAS(웹 어플리케이션 서버)*** 를 하나 두고 클라이언트로부터 요청이 들어오면 WAS에게 넘긴다.  
5. WAS는 요청에 맞는 기능을 수행하기 위해 ***서블릿***을 실행하여 요청에 맞는 페이지를 동적으로 생성해서 서버에게 보내고, 서버는 그 페이지를 클라이언트에게 보낸다.  
6. 클라이언트로부터 정적인 페이지 요청이 들어올 때도 있는데 그럴 땐 보통 WAS까지 가지 않고 서버에서 해결 한다.  
  
***서블릿***은 위처럼 WAS가 동적인 페이지를 만들기 위해 사용하는 자바로 만들어진 ***CGI 프로그램***이다.  
※CGI -  서버 프로그램에서 다른 프로그램을 불러내고, 그 처리 결과를 클라이언트에 송신하는 방법이 고안되었다. 이를 실현하기 위한 서버 프로그램과 외부 프로그램과의 연계법을 정한 것  
***  
***서블릿 특징***  
---------------------------------------------------------------------
1. 자바로 작성되었기에 자바의 일반적인 특징을 모두 가지긴 한다. 다만 일반 자바 프로그램과는 달리 컨테이너에서만 실행이 된다.  
2. 자바의 쓰레드 기능을 활용한다. 즉, 여러 클라이언트로부터 같은 요청이 들어오면 WAS는 서블릿을 들어온 요청의 수만큼 생성하지 않고, 같은 요청에 대해서는 하나만 생성해서 다 처리를 한다. 12첩반상을 먹으면 젓가락 12개 놓고 먹는 게 아니라 하나로만 먹는 느낌이다.  
  
따라서 서블릿의 동작 과정은    
1. WAS가 요청을 수행하려 하면 해당 요청을 수행하는 서블릿이 이미 메모리에 있는 지 확인.  
2. 없다면 생성해서 해당 요청을 수행하고, 있다면 그 서블릿으로 요청 수행.  
3. 서블릿이 언제 삭제가 되는 지는 아직 모르겠으나 눈치껏 자길 찾는 사람이 없다면 조용히 혼자 사라졌으면 좋겠음. 이건 나중에 찾아봐야지  
***
**서블릿 생명주기** 메서드 기능  
---------------------------------------------------------------------  
-초기화 단계 : init() 호출 -> 서블릿 요청 시 맨 처음 한 번만 호출, 서블릿 생성 시 초기화 작업을 주로 수행  
-작업 수행 단계 : doget() or dopost() 호출 -> 서블릿 요청 시 매번 호출, 실제로 클라이언트가 요청하는 작업 수행  
-종료 단계 : destroy() 호출 -> 서블릿이 기능을 수행하고 메모리에서 소멸될 때 호출, 서블릿의 마무리 작업을 주로 수행   

※초기 설정과 종료 작업이 필요 없다면 init() destroy() 생략 가능  
***
**servlet3 내용**
---------------------------------------------------------------------  
서블릿을 맵핑할 때 해당 프로젝트의 web.xml 파일에  
  ![image](https://user-images.githubusercontent.com/51132077/85551596-1cd29d00-b65d-11ea-8c3f-880e533e14a8.png)

해당 코드를 추가해서 서블릿을 맵핑시킬 수 있음  
이렇게 하면 http://localhost:8080/servlet2/servlet2.ex.FirstServlet 을  http://localhost:8080/servlet2/first 로 호출할 수 있음  
**사용이유?**  
아무래도 맵핑 전 상태처럼 클래스 이름이 다 노출된다면 이름만 보고 해당 클래스의 역할이 뭔 지를 유추해서 악용될 위험이 있으니 맵핑을 이용하여 숨김  

근데 클래스마다 web.xml에 저렇게 코드로 맵핑하는 건 너무 귀찮음  
![image](https://user-images.githubusercontent.com/51132077/85551928-72a74500-b65d-11ea-9846-6dad1d465aed.png)

web.xml에 맵핑하지 않고 위 사진처럼 해당 클래스 머리 위에 저렇게 직접 맵핑을 시킬 수 있음. **어노테이션**이라고도 부르고 **애너테이션**이라고도 부름.  
나는 어노테이션이 편하다.  
아무 클래서 머리 위에 저렇게 쓴다고 해서 맵핑이 되는 게 아니라 HttpServlet을 상속 받아야 맵핑이 된다!..  
***
**servlet4 내용**  
---------------------------------------------------------------------  

서블릿과 JSP는 HTML, CSS, 자바스크립트 같은 기존의 것을 버리지 않고 여기에 자신의 기능을 추가하여 서로 연동하여 동작할 수 있다.  
특히 사용자의 요청은 HTML의 <form> 태그나 자바스크립트로부터 전송 받아서 처리할 수 있다.  
![image](https://user-images.githubusercontent.com/51132077/85740349-85dd1200-b73c-11ea-903c-68e8196eaaed.png)
  
이렇게 form 태그를 통해 클라이언트가 요청하면 컨테이너가 먼저 받게 된다. 그런 다음 사용자의 요청인 응답에 대한 HttpServletRequest 객체와 HttpServletResponse 객체를 만들고 서블릿의 doGet() 이나 doPost() 메서드를 호출하면서 이 객체들을 전달한다.  
즉, 서블릿 입장에서는 **클라이언트가 보낸 데이터들은 HttpServletRequest**에 담긴 상태로 받고, **요청에 대한 응답에 관한 데이터들은 HttpServletResponse**에 담아 클라이언트에게 보낸다.  

클라이언트가 보낸 데이터들은 input 태그의 name 속성 값과 쌍으로 전송 되는데  
String getParameter(String name) : name의 값을 알고 있을 때 그리고 name에 대한 전송된 값을 받아오는 데 사용  
String getParameterValues(String name) : 같은 name에 대해 여러 개의 값을 얻을 때 사용  
Enumeration getParameterNames() : name 값을 모를 때 사용  
서블릿은 위 HttpServletRequest의 메서드를 이용하여 데이터들을 확인할 수 있다.  
  
